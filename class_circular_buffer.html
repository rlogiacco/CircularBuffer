<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CircularBuffer: CircularBuffer&lt; T, S, IT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CircularBuffer
   </div>
   <div id="projectbrief">Arduino circular buffer library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_circular_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CircularBuffer&lt; T, S, IT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements a circular buffer that supports LIFO and FIFO operations.  
 <a href="class_circular_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_circular_buffer_8hpp_source.html">CircularBuffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa2a157916d8cb575f9eadf279cc40dbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#aa2a157916d8cb575f9eadf279cc40dbf">index_t</a> = IT</td></tr>
<tr class="memdesc:aa2a157916d8cb575f9eadf279cc40dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aliases the index type.  <a href="class_circular_buffer.html#aa2a157916d8cb575f9eadf279cc40dbf">More...</a><br /></td></tr>
<tr class="separator:aa2a157916d8cb575f9eadf279cc40dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4aeba2ac5ecf5348ee4b38c6efbb1243"><td class="memItemLeft" align="right" valign="top"><a id="a4aeba2ac5ecf5348ee4b38c6efbb1243" name="a4aeba2ac5ecf5348ee4b38c6efbb1243"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>CircularBuffer</b> ()</td></tr>
<tr class="memdesc:a4aeba2ac5ecf5348ee4b38c6efbb1243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty circular buffer. <br /></td></tr>
<tr class="separator:a4aeba2ac5ecf5348ee4b38c6efbb1243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866947949a84a6037b43ab373b05b175"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a866947949a84a6037b43ab373b05b175">unshift</a> (T value)</td></tr>
<tr class="memdesc:a866947949a84a6037b43ab373b05b175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the beginning of buffer.  <a href="class_circular_buffer.html#a866947949a84a6037b43ab373b05b175">More...</a><br /></td></tr>
<tr class="separator:a866947949a84a6037b43ab373b05b175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b18f285fe95646b0c665d5ab31d9116"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a0b18f285fe95646b0c665d5ab31d9116">push</a> (T value)</td></tr>
<tr class="memdesc:a0b18f285fe95646b0c665d5ab31d9116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the end of buffer.  <a href="class_circular_buffer.html#a0b18f285fe95646b0c665d5ab31d9116">More...</a><br /></td></tr>
<tr class="separator:a0b18f285fe95646b0c665d5ab31d9116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2b472aad3740665d3d3962aeeb81f3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a4b2b472aad3740665d3d3962aeeb81f3">shift</a> ()</td></tr>
<tr class="memdesc:a4b2b472aad3740665d3d3962aeeb81f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the beginning of the buffer.  <a href="class_circular_buffer.html#a4b2b472aad3740665d3d3962aeeb81f3">More...</a><br /></td></tr>
<tr class="separator:a4b2b472aad3740665d3d3962aeeb81f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ba52b2ff9af891659c57a6b78da575"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#aa3ba52b2ff9af891659c57a6b78da575">pop</a> ()</td></tr>
<tr class="memdesc:aa3ba52b2ff9af891659c57a6b78da575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the end of the buffer.  <a href="class_circular_buffer.html#aa3ba52b2ff9af891659c57a6b78da575">More...</a><br /></td></tr>
<tr class="separator:aa3ba52b2ff9af891659c57a6b78da575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834bb7d9d01784437070f72c1c3257bf"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a834bb7d9d01784437070f72c1c3257bf">first</a> () const</td></tr>
<tr class="memdesc:a834bb7d9d01784437070f72c1c3257bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the beginning of the buffer.  <a href="class_circular_buffer.html#a834bb7d9d01784437070f72c1c3257bf">More...</a><br /></td></tr>
<tr class="separator:a834bb7d9d01784437070f72c1c3257bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af417917b97ee513a3c63f056a7667c33"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#af417917b97ee513a3c63f056a7667c33">last</a> () const</td></tr>
<tr class="memdesc:af417917b97ee513a3c63f056a7667c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the end of the buffer.  <a href="class_circular_buffer.html#af417917b97ee513a3c63f056a7667c33">More...</a><br /></td></tr>
<tr class="separator:af417917b97ee513a3c63f056a7667c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63875d001e0dd06a7b67193527ce642"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#ad63875d001e0dd06a7b67193527ce642">operator[]</a> (IT index) const</td></tr>
<tr class="memdesc:ad63875d001e0dd06a7b67193527ce642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array-like access to buffer.  <a href="class_circular_buffer.html#ad63875d001e0dd06a7b67193527ce642">More...</a><br /></td></tr>
<tr class="separator:ad63875d001e0dd06a7b67193527ce642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7c41366af671a452391f1553b0a1ca"><td class="memItemLeft" align="right" valign="top">IT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a7d7c41366af671a452391f1553b0a1ca">size</a> () const</td></tr>
<tr class="memdesc:a7d7c41366af671a452391f1553b0a1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many elements are actually stored in the buffer.  <a href="class_circular_buffer.html#a7d7c41366af671a452391f1553b0a1ca">More...</a><br /></td></tr>
<tr class="separator:a7d7c41366af671a452391f1553b0a1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2bc9b5b2b3dc38088261124a983b89"><td class="memItemLeft" align="right" valign="top">IT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a6e2bc9b5b2b3dc38088261124a983b89">available</a> () const</td></tr>
<tr class="memdesc:a6e2bc9b5b2b3dc38088261124a983b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many elements can be safely pushed into the buffer.  <a href="class_circular_buffer.html#a6e2bc9b5b2b3dc38088261124a983b89">More...</a><br /></td></tr>
<tr class="separator:a6e2bc9b5b2b3dc38088261124a983b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4842aa849f51c3326949e97202d4f92b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a4842aa849f51c3326949e97202d4f92b">isEmpty</a> () const</td></tr>
<tr class="memdesc:a4842aa849f51c3326949e97202d4f92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is empty.  <a href="class_circular_buffer.html#a4842aa849f51c3326949e97202d4f92b">More...</a><br /></td></tr>
<tr class="separator:a4842aa849f51c3326949e97202d4f92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004968b672bf01358e5ceeaa6ff702f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a004968b672bf01358e5ceeaa6ff702f8">isFull</a> () const</td></tr>
<tr class="memdesc:a004968b672bf01358e5ceeaa6ff702f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is full.  <a href="class_circular_buffer.html#a004968b672bf01358e5ceeaa6ff702f8">More...</a><br /></td></tr>
<tr class="separator:a004968b672bf01358e5ceeaa6ff702f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef199d78df0e0d0ee3996ad251ad90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#acef199d78df0e0d0ee3996ad251ad90c">clear</a> ()</td></tr>
<tr class="memdesc:acef199d78df0e0d0ee3996ad251ad90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the buffer to a clean status, making all buffer positions available.  <a href="class_circular_buffer.html#acef199d78df0e0d0ee3996ad251ad90c">More...</a><br /></td></tr>
<tr class="separator:acef199d78df0e0d0ee3996ad251ad90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b21c32bc92aa54560a49c5fc72b2cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a4b21c32bc92aa54560a49c5fc72b2cf1">copyToArray</a> (T *out) const</td></tr>
<tr class="memdesc:a4b21c32bc92aa54560a49c5fc72b2cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the buffer content into the provided array.  <a href="class_circular_buffer.html#a4b21c32bc92aa54560a49c5fc72b2cf1">More...</a><br /></td></tr>
<tr class="separator:a4b21c32bc92aa54560a49c5fc72b2cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b317d2673db8674924d686da31977d"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ae9b317d2673db8674924d686da31977d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#ae9b317d2673db8674924d686da31977d">copyToArray</a> (R *out, R(&amp;convertFn)(const T &amp;)) const</td></tr>
<tr class="memdesc:ae9b317d2673db8674924d686da31977d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the buffer content into the provided array calling the provided conversion function for each and every element of the buffer.  <a href="class_circular_buffer.html#ae9b317d2673db8674924d686da31977d">More...</a><br /></td></tr>
<tr class="separator:ae9b317d2673db8674924d686da31977d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6b9f78cef4d42d04ec643bcefedc0840"><td class="memItemLeft" align="right" valign="top">static constexpr IT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_circular_buffer.html#a6b9f78cef4d42d04ec643bcefedc0840">capacity</a> = static_cast&lt;IT&gt;(S)</td></tr>
<tr class="memdesc:a6b9f78cef4d42d04ec643bcefedc0840"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer capacity.  <a href="class_circular_buffer.html#a6b9f78cef4d42d04ec643bcefedc0840">More...</a><br /></td></tr>
<tr class="separator:a6b9f78cef4d42d04ec643bcefedc0840"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, size_t S, typename IT = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt;<br />
class CircularBuffer&lt; T, S, IT &gt;</div><p >Implements a circular buffer that supports LIFO and FIFO operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to store in the buffer. </td></tr>
    <tr><td class="paramname">S</td><td>The maximum number of elements that can be stored in the buffer. </td></tr>
    <tr><td class="paramname">IT</td><td>The data type of the index. Typically should be left as default. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa2a157916d8cb575f9eadf279cc40dbf" name="aa2a157916d8cb575f9eadf279cc40dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a157916d8cb575f9eadf279cc40dbf">&#9670;&nbsp;</a></span>index_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::<a class="el" href="class_circular_buffer.html#aa2a157916d8cb575f9eadf279cc40dbf">index_t</a> =  IT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aliases the index type. </p>
<p >Can be used to obtain the right index type with <code>decltype(buffer)::index_t</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e2bc9b5b2b3dc38088261124a983b89" name="a6e2bc9b5b2b3dc38088261124a983b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2bc9b5b2b3dc38088261124a983b89">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IT <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many elements can be safely pushed into the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements that can be safely pushed into the buffer. </dd></dl>

</div>
</div>
<a id="acef199d78df0e0d0ee3996ad251ad90c" name="acef199d78df0e0d0ee3996ad251ad90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef199d78df0e0d0ee3996ad251ad90c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the buffer to a clean status, making all buffer positions available. </p>
<dl class="section note"><dt>Note</dt><dd>This does not clean up any dynamically allocated memory stored in the buffer. Clearing a buffer that points to heap-allocated memory may cause a memory leak, if it's not properly cleaned up. </dd></dl>

</div>
</div>
<a id="ae9b317d2673db8674924d686da31977d" name="ae9b317d2673db8674924d686da31977d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b317d2673db8674924d686da31977d">&#9670;&nbsp;</a></span>copyToArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::copyToArray </td>
          <td>(</td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(&amp;)(const T &amp;)&#160;</td>
          <td class="paramname"><em>convertFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the buffer content into the provided array calling the provided conversion function for each and every element of the buffer. </p>
<dl class="section note"><dt>Note</dt><dd>No verification is done about the provided array length, it's the user responsibility to ensure the array provides enough space to accomodate all the elements currently stored in the buffer. After the function returns the elements in the buffer can be found starting at index 0 and up to the buffer <a class="el" href="class_circular_buffer.html#a7d7c41366af671a452391f1553b0a1ca" title="Returns how many elements are actually stored in the buffer.">size()</a> at the moment of the copyToArray function call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">convertFn</td><td>the conversion function to call for each item stored in the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b21c32bc92aa54560a49c5fc72b2cf1" name="a4b21c32bc92aa54560a49c5fc72b2cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b21c32bc92aa54560a49c5fc72b2cf1">&#9670;&nbsp;</a></span>copyToArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::copyToArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the buffer content into the provided array. </p>
<dl class="section note"><dt>Note</dt><dd>No verification is done about the provided array length, it's the user responsibility to ensure the array provides enough space to accomodate all the elements currently stored in the buffer. After the function returns the elements in the buffer can be found starting at index 0 and up to the buffer <a class="el" href="class_circular_buffer.html#a7d7c41366af671a452391f1553b0a1ca" title="Returns how many elements are actually stored in the buffer.">size()</a> at the moment of the copyToArray function call. </dd></dl>

</div>
</div>
<a id="a834bb7d9d01784437070f72c1c3257bf" name="a834bb7d9d01784437070f72c1c3257bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834bb7d9d01784437070f72c1c3257bf">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the beginning of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The element at the beginning of the buffer. </dd></dl>

</div>
</div>
<a id="a4842aa849f51c3326949e97202d4f92b" name="a4842aa849f51c3326949e97202d4f92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4842aa849f51c3326949e97202d4f92b">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff no elements can be removed from the buffer. </dd></dl>

</div>
</div>
<a id="a004968b672bf01358e5ceeaa6ff702f8" name="a004968b672bf01358e5ceeaa6ff702f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004968b672bf01358e5ceeaa6ff702f8">&#9670;&nbsp;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::isFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer is full. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no elements can be added to the buffer without overwriting existing elements. </dd></dl>

</div>
</div>
<a id="af417917b97ee513a3c63f056a7667c33" name="af417917b97ee513a3c63f056a7667c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af417917b97ee513a3c63f056a7667c33">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the end of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The element at the end of the buffer. </dd></dl>

</div>
</div>
<a id="ad63875d001e0dd06a7b67193527ce642" name="ad63875d001e0dd06a7b67193527ce642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63875d001e0dd06a7b67193527ce642">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array-like access to buffer. </p>
<p >Calling this operation using and index value greater than <code>size - 1</code> returns the tail element.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling this operation on an empty buffer has an unpredictable behaviour. </dd></dl>

</div>
</div>
<a id="aa3ba52b2ff9af891659c57a6b78da575" name="aa3ba52b2ff9af891659c57a6b78da575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ba52b2ff9af891659c57a6b78da575">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an element from the end of the buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Calling this operation on an empty buffer has an unpredictable behaviour. </dd></dl>

</div>
</div>
<a id="a0b18f285fe95646b0c665d5ab31d9116" name="a0b18f285fe95646b0c665d5ab31d9116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b18f285fe95646b0c665d5ab31d9116">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::push </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to the end of buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> iff the addition caused overwriting to an existing element. </dd></dl>

</div>
</div>
<a id="a4b2b472aad3740665d3d3962aeeb81f3" name="a4b2b472aad3740665d3d3962aeeb81f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2b472aad3740665d3d3962aeeb81f3">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::shift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an element from the beginning of the buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Calling this operation on an empty buffer has an unpredictable behaviour. </dd></dl>

</div>
</div>
<a id="a7d7c41366af671a452391f1553b0a1ca" name="a7d7c41366af671a452391f1553b0a1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7c41366af671a452391f1553b0a1ca">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IT <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many elements are actually stored in the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements stored in the buffer. </dd></dl>

</div>
</div>
<a id="a866947949a84a6037b43ab373b05b175" name="a866947949a84a6037b43ab373b05b175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866947949a84a6037b43ab373b05b175">&#9670;&nbsp;</a></span>unshift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::unshift </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to the beginning of buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> iff the addition caused overwriting to an existing element. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6b9f78cef4d42d04ec643bcefedc0840" name="a6b9f78cef4d42d04ec643bcefedc0840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9f78cef4d42d04ec643bcefedc0840">&#9670;&nbsp;</a></span>capacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S, typename IT  = typename Helper::Index&lt;(S &lt;= UINT8_MAX), (S &lt;= UINT16_MAX)&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IT <a class="el" href="class_circular_buffer.html">CircularBuffer</a>&lt; T, S, IT &gt;::capacity = static_cast&lt;IT&gt;(S)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The buffer capacity. </p>
<p >Read only as it cannot ever change. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_circular_buffer_8hpp_source.html">CircularBuffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
