<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CircularBuffer: ⚠ &lt;strong&gt;IMPORTANT&lt;/strong&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CircularBuffer
   </div>
   <div id="projectbrief">Arduino circular buffer library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">⚠ <b>IMPORTANT</b> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> </p><blockquote class="doxtable">
<p >Please, before submitting a support request read carefully this README and check if an answer already exists among <a href="https://github.com/rlogiacco/CircularBuffer/discussions">previously answered questions</a>: do not abuse of the Github issue tracker. </p>
</blockquote>
<h1><a class="el" href="class_circular_buffer.html" title="Implements a circular buffer that supports LIFO and FIFO operations.">CircularBuffer</a> <a href="https://github.com/rlogiacco/CircularBuffer/stargazers"><img src="https://img.shields.io/github/stars/rlogiacco/CircularBuffer.svg?style=social&amp;label=Star" alt="GitHub stars" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/rlogiacco/CircularBuffer/network"><img src="https://img.shields.io/github/forks/rlogiacco/CircularBuffer.svg?style=social&amp;label=Fork" alt="GitHub forks" style="pointer-events: none;" class="inline"/></a> <a href="https://twitter.com/intent/tweet?text=Roll%20your%20data%20on%20embedded%20devices%20easily!&amp;url=https://github.com/rlogiacco/CircularBuffer&amp;hashtags=IoT,Arduino,ESP8266,ESP32"><img src="https://img.shields.io/twitter/url/http/shields.io.svg?style=social" alt="Tweet" style="pointer-events: none;" class="inline"/></a> </h1>
<p ><a href="https://github.com/rlogiacco/CircularBuffer/releases"><img src="https://img.shields.io/github/release/rlogiacco/CircularBuffer.svg" alt="GitHub version" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/rlogiacco/CircularBuffer/releases/latest"><img src="https://img.shields.io/github/downloads/rlogiacco/CircularBuffer/total.svg" alt="GitHub download" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/rlogiacco/CircularBuffer/stargazers"><img src="https://img.shields.io/github/stars/rlogiacco/CircularBuffer.svg" alt="GitHub stars" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/rlogiacco/CircularBuffer/issues"><img src="https://img.shields.io/github/issues/rlogiacco/CircularBuffer.svg" alt="GitHub issues" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/rlogiacco/CircularBuffer/actions/workflows/main.yml"><img src="https://github.com/rlogiacco/CircularBuffer/actions/workflows/main.yml/badge.svg" alt="Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/rlogiacco/CircularBuffer/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-LGPL%203-blue.svg" alt="License" style="pointer-events: none;" class="inline"/></a></p>
<p >The library itself has an implicit memory consumption of about <em>0.5Kb</em>: 580 bytes (max) of code and 8 bytes of memory, according to my calculations. That does not consider the space used to store the items themselves, obviously.</p>
<ul>
<li><a href="#usage">Usage</a><ul>
<li><a href="#declare-and-initialize">Declare and initialize</a></li>
<li><a href="#store-data">Store data</a></li>
<li><a href="#retrieve-data">Retrieve data</a></li>
<li><a href="#additional-operations">Additional operations</a></li>
</ul>
</li>
<li><a href="#advanced-usage">Advanced Usage</a><ul>
<li><a href="#automatic-optimization">Automatic optimization</a></li>
<li><a href="#legacy-optimization">Legacy optimization</a></li>
<li><a href="#interrupts">Interrupts</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a></li>
<li><a href="#limitations">Limitations</a><ul>
<li><a href="#reclaim-dynamic-memory">Reclaim dynamic memory</a></li>
</ul>
</li>
<li><a href="#change-log">CHANGE LOG</a><ul>
<li><a href="#140">1.4.0</a></li>
<li><a href="#133">1.3.3</a></li>
<li><a href="#132">1.3.2</a></li>
<li><a href="#131">1.3.1</a></li>
<li><a href="#130">1.3.0</a></li>
<li><a href="#120">1.2.0</a></li>
<li><a href="#111">1.1.1</a></li>
<li><a href="#110">1.1.0</a></li>
<li><a href="#100">1.0.0</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Declare and initialize</h2>
<p >When declaring your buffer you should specify the data type it must handle and the buffer capacity: those two parameters will influence the memory consumed by the buffer.</p>
<div class="fragment"><div class="line">#include &lt;CircularBuffer.hpp&gt;</div>
<div class="line"> </div>
<div class="line">CircularBuffer&lt;byte,100&gt; bytes;     // uses 538 bytes</div>
<div class="line">CircularBuffer&lt;int,100&gt; ints;       // uses 638 bytes</div>
<div class="line">CircularBuffer&lt;long,100&gt; longs;     // uses 838 bytes</div>
<div class="line">CircularBuffer&lt;float,100&gt; floats;   // uses 988 bytes</div>
<div class="line">CircularBuffer&lt;double,100&gt; doubles; // uses 988 bytes</div>
<div class="line">CircularBuffer&lt;char,100&gt; chars;     // uses 538 bytes </div>
<div class="line">CircularBuffer&lt;void*,100&gt; pointers; // uses 638 bytes</div>
</div><!-- fragment --><p ><b>Please note</b>: the memory usage reported above includes the program memory used by the library code, the heap memory is much less and is comparable to an array of the same size and type of the buffer.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Store data</h2>
<p >Let's start making things clear: the library doesn't support inserting data in the middle of the buffer. You can add data to the buffer either before the first element via an <code>unshift()</code> operation or after the last element via a <code>push()</code> operation. You can keep adding data beyond the buffer maximum capacity, but you'll lose the least significant information:</p>
<ul>
<li>since <code>unshift()</code> adds to the <em>head</em>, adding beyond capacity causes the element at <em>tail</em> to be overwritten and lost</li>
<li>since <code>push()</code> adds to the <em>tail</em>, adding beyond capacity causes the element at <em>head</em> to be overwritten and lost</li>
</ul>
<p >Both <code>unshift()</code> and <code>push()</code> return <code>true</code> if the addition didn't cause any information loss, <code>false</code> if an overwrite occurred:</p>
<div class="fragment"><div class="line">CircularBuffer&lt;int,5&gt; buffer; // buffer capacity is 5</div>
<div class="line"> </div>
<div class="line">// all of the following return true</div>
<div class="line">buffer.unshift(1); // [1] </div>
<div class="line">buffer.unshift(2); // [2,1]</div>
<div class="line">buffer.unshift(3); // [3,2,1]</div>
<div class="line">buffer.push(0);  // [3,2,1,0]</div>
<div class="line">buffer.push(5);  // [3,2,1,0,5]</div>
<div class="line"> </div>
<div class="line">// buffer is now at full capacity, from now on any addition returns false</div>
<div class="line">buffer.unshift(2);  // [2,3,2,1,0] returns false</div>
<div class="line">buffer.unshift(10); // [10,2,3,2,1] returns false</div>
<div class="line">buffer.push(-5);  // [2,3,2,1,-5] returns false</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Retrieve data</h2>
<p >Similarly to data addition, data retrieval can be performed at <em>tail</em> via a <code>pop()</code> operation or from <em>head</em> via a <code>shift</code><code>()</code>` operation: both cause the element being read to be removed from the buffer.</p>
<blockquote class="doxtable">
<p >⚠ Reading data beyond the actual buffer size has an undefined behaviour and is user's responsibility to prevent such boundary violations using the <a href="#additional-operations"><em>additional operations</em></a> listed in the next section. The library will behave differently depending on the data type and allocation method, but you can safely assume your program will crash if you don't watch your steps. </p>
</blockquote>
<p>Non-destructive read operations are also available:</p>
<ul>
<li><code>first()</code> returns the element at <em>head</em></li>
<li><code>last()</code> returns the element at <em>tail</em></li>
<li>an array-like indexed read operation is also available so you can read any element in the buffer using the <code>[]</code> operator</li>
</ul>
<div class="fragment"><div class="line">CircularBuffer&lt;char, 50&gt; buffer; // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;]</div>
<div class="line"> </div>
<div class="line">buffer.first(); // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;] returns &#39;a&#39;</div>
<div class="line">buffer.last(); // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;] returns &#39;g&#39;</div>
<div class="line">buffer.pop(); // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;] returns &#39;g&#39;</div>
<div class="line">buffer.pop(); // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returns &#39;f&#39;</div>
<div class="line">buffer.shift(); // [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returns &#39;a&#39;</div>
<div class="line">buffer.shift(); // [&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returns &#39;b&#39;</div>
<div class="line">buffer[0]; // [&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returns &#39;c&#39;</div>
<div class="line">buffer[1]; // [&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returns &#39;d&#39;</div>
<div class="line">buffer[2]; // [&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returns &#39;e&#39;</div>
<div class="line"> </div>
<div class="line">buffer[10]; // [&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returned value is unpredictable</div>
<div class="line">buffer[15]; // [&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] returned value is unpredictable</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Additional operations</h2>
<ul>
<li><code>isEmpty()</code> returns <code>true</code> only if no data is stored in the buffer</li>
<li><code>isFull()</code> returns <code>true</code> if no data can be further added to the buffer without causing overwrites/data loss</li>
<li><code>size()</code> returns the number of elements currently stored in the buffer; it should be used in conjunction with the <code>[]</code> operator to avoid boundary violations: the first element index is always <code>0</code> (if buffer is not empty), the last element index is always <code>size() - 1</code></li>
<li><code>available()</code> returns the number of elements that can be added before saturating the buffer</li>
<li><code>capacity()</code> returns the number of elements the buffer can store, for completeness only as it's user-defined and never changes <b>REMOVED</b> from <code>1.3.0</code> replaced by the read-only member variable <code>capacity</code></li>
<li><code>clear()</code> resets the whole buffer to its initial state (pay attention though, if you had dynamically allocated objects in your buffer, memory used by such object is <em>not</em> released: iterate over the buffer contents and release objects accordingly to their allocation method)</li>
<li><code>copyToArray(array)</code> copies the contents of the buffer to a standard array <code>array</code>. The array must be large enough to hold all the elements currently in the buffer.</li>
<li><code>copyToArray(conversionFn, array)</code> copies the contents of the buffer to a standard array <code>array</code> executing a function on each element, usually a type conversion. The array must be large enough to hold all the elements currently in the buffer.</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Advanced Usage</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Automatic optimization</h2>
<p >Starting from version <code>1.3.0</code> the library is capable to automatically detecting which data type should be used for the index based on the buffer capacity:</p><ul>
<li>if you declare a buffer with a capacity greater than <code>65535</code> then your index is going to be an <code>unsigned long</code></li>
<li><code>unsigned int</code> for buffers with a declared capacity greater than <code>255</code></li>
<li>otherwise, a <code>byte</code> is going to suffice</li>
</ul>
<p >In addition, you can mix in the same code buffers with small index and buffers with normal index: previously this was not possible.</p>
<div class="fragment"><div class="line">CircularBuffer&lt;char,100&gt; optimizedBuffer; // reduced memory footprint, index type is uint8_t (a.k.a. byte)</div>
<div class="line">CircularBuffer&lt;long,500&gt; normalBuffer;    // standard memory footprint, index type is unit16_t (a.k.a. unsigned int)</div>
<div class="line">CircularBuffer&lt;int,66000&gt; hugeBuffer;     // extended memory footprint, index type is unit32_t (a.k.a. unsigned long)</div>
</div><!-- fragment --><p >To obtain the maximum advantage of the optimization above, anytime you need to refer to the buffer index you should use the most appropriate type: this can be easily achieved using the <code>decltype</code> specifier, like in the following example:</p>
<div class="fragment"><div class="line"><span class="comment">// the iterator variable i is of the correct type, even if  </span></div>
<div class="line"><span class="comment">// we don&#39;t know what&#39;s the buffer declared capacity</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">decltype</span>(buffer)::index_t i = 0; i &lt; buffer.size(); i++) {</div>
<div class="line">    avg += buffer[i] / buffer.size();</div>
<div class="line">}</div>
</div><!-- fragment --><p >If you prefer, you can alias the index type and refer to such alias:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> index_t = <span class="keyword">decltype</span>(buffer)::index_t;</div>
<div class="line"><span class="keywordflow">for</span> (index_t i = 0; i &lt; buffer.size(); i++) {</div>
<div class="line">    avg += buffer[i] / buffer.size();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Legacy optimization</h2>
<p ><em>The following applies to versions prior to <code>1.3.0</code> only.</em></p>
<p >By default the library uses <code>unsigned int</code> indexes, allowing for a maximum of <code>65535</code> items, but you'll rarely need such a huge store.</p>
<p >You can switch the library indexes to <code>byte</code> type defining the <code>CIRCULAR_BUFFER_XS</code> macro <b>BEFORE</b> the <code>#include</code> directive: this reduces the memory used by the library itself by only <code>36</code> bytes, but allows you to potentially squeeze out much more whenever you perform an indexed access, if you do any, by using the smaller data type.</p>
<div class="fragment"><div class="line">#define CIRCULAR_BUFFER_XS</div>
<div class="line">#include &lt;CircularBuffer.h&gt;</div>
<div class="line"> </div>
<div class="line">CircularBuffer&lt;short,100&gt; buffer;</div>
<div class="line"> </div>
<div class="line">void setup() { }</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">    // here i should be declared of type byte rather than unsigned int</div>
<div class="line">    // in order to maximize the effects of the optimization</div>
<div class="line">    for (byte i = 0; i &lt; buffer.size() - 1; i++) {</div>
<div class="line">        Serial.print(buffer[i]);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p ><b>Please note</b>: this <em>macro switch</em> forces the buffer to use an 8 bits data type as the internal index, as such <b>all</b> your buffers will be limited to a maximum capacity of <code>255</code>.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Interrupts</h2>
<p >The library does help to work with interrupts defining the <code>CIRCULAR_BUFFER_INT_SAFE</code> macro switch, which introduces the <code>volatile</code> modifier to the <code>count</code> variable, making the whole library more interrupt-friendly at the price of disabling some compiler optimizations. The <code>#define</code> statement needs to be put somewhere before the <code>#include</code> statement:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CIRCULAR_BUFFER_INT_SAFE</span></div>
<div class="line"><span class="preprocessor">#include &lt;CircularBuffer.h&gt;</span></div>
<div class="line"><a class="code hl_class" href="class_circular_buffer.html">CircularBuffer&lt;unsigned long, 10&gt;</a> timings;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> count() {</div>
<div class="line">  timings.<a class="code hl_function" href="class_circular_buffer.html#a0b18f285fe95646b0c665d5ab31d9116">push</a>(millis());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">    attachInterrupt(digitalPinToInterrupt(2), count, RISING);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> loop() {</div>
<div class="line">    Serial.print(<span class="stringliteral">&quot;buffer size is &quot;</span>); Serial.println(timings.<a class="code hl_function" href="class_circular_buffer.html#a7d7c41366af671a452391f1553b0a1ca">size</a>());</div>
<div class="line">    delay(250);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_circular_buffer_html"><div class="ttname"><a href="class_circular_buffer.html">CircularBuffer</a></div><div class="ttdoc">Implements a circular buffer that supports LIFO and FIFO operations.</div><div class="ttdef"><b>Definition:</b> CircularBuffer.hpp:51</div></div>
<div class="ttc" id="aclass_circular_buffer_html_a0b18f285fe95646b0c665d5ab31d9116"><div class="ttname"><a href="class_circular_buffer.html#a0b18f285fe95646b0c665d5ab31d9116">CircularBuffer::push</a></div><div class="ttdeci">bool push(T value)</div><div class="ttdoc">Adds an element to the end of buffer.</div></div>
<div class="ttc" id="aclass_circular_buffer_html_a7d7c41366af671a452391f1553b0a1ca"><div class="ttname"><a href="class_circular_buffer.html#a7d7c41366af671a452391f1553b0a1ca">CircularBuffer::size</a></div><div class="ttdeci">IT size() const</div><div class="ttdoc">Returns how many elements are actually stored in the buffer.</div></div>
</div><!-- fragment --><blockquote class="doxtable">
<p >Please note this does <b>NOT</b> make the library <em>interrupt safe</em>, but it does help its usage in interrupt driven firmwares. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md10"></a>
Examples</h1>
<p >Multiple examples are available in the <code>examples</code> folder of the library:</p>
<ul>
<li><a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/CircularBuffer/CircularBuffer.ino">CircularBuffer.ino</a> shows how you can use the library to create a continous averaging of the most recent readings</li>
<li><a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/EventLogging/EventLogging.ino">EventLogging.ino</a> focuses on dumping the buffer when it becomes full and printing the buffer contents periodically at the same time</li>
<li><a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/Object/Object.ino">Object.ino</a> is meant to demonstrate how to use the buffer to store dynamic structures</li>
<li><a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/Queue/Queue.ino">Queue.ino</a> is a classical example of a queue, or a FIFO data structure</li>
<li><a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/Stack/Stack.ino">Stack.ino</a> on the other end shows how to use the library to represent a LIFO data structure</li>
<li><a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/Struct/Struct.ino">Struct.ino</a> answers to the question <em>can this library store structured data?</em></li>
<li><a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/Interrupts/Interrupts.ino">Interrupts.ino</a> demonstrates the use of the library in interrupt-driven code</li>
<li>[Arrays.ino]() demonstrates the use of the <code>copyToArray()</code> functions.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Limitations</h1>
<h2><a class="anchor" id="autotoc_md12"></a>
Reclaim dynamic memory</h2>
<p >If you use this library to store dynamically allocated objects, refrain from using the <code>clear()</code> method as that will <b>not</b> perform memory deallocation: you need to iterate over your buffer content and release memory accordingly to the allocation method used, either via <code>delete</code> (if you had used <code>new</code>) or <code>free</code> (in case of <code>malloc</code>):</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!buffer.isEmpty()) {</div>
<div class="line">    <span class="comment">// pick the correct one</span></div>
<div class="line">    <span class="keyword">delete</span> buffer.pop();</div>
<div class="line">    free(buffer.pop());</div>
<div class="line">}</div>
</div><!-- fragment --><p >The very same applies for the <code>pop()</code> and <code>shift()</code> operations as any dynamically allocated object is only <em>detached</em> from the buffer, but the memory it uses is <b>not</b> automagically released (see the <a href="https://github.com/rlogiacco/CircularBuffer/blob/master/examples/Object/Object.ino">Object.ino</a> example)</p>
<div class="fragment"><div class="line">Record* record = <span class="keyword">new</span> Record(millis(), sample);  <span class="comment">// a dynamically allocated object</span></div>
<div class="line">buffer.push(record);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// somewhere else</span></div>
<div class="line"><span class="keywordflow">if</span> (!buffer.isEmpty()) {</div>
<div class="line">    Record* current = buffer.pop();</div>
<div class="line">    Serial.println(current.value());</div>
<div class="line">    <span class="keyword">delete</span> current; <span class="comment">// if you don&#39;t do this the object memory is lost!!!</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md14"></a>
CHANGE LOG</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
1.4.0</h2>
<ul>
<li>Resolves #52 adding two new additional methods <code>copyToArray(array)</code> and <code>copyToArray(array, convertFn)</code></li>
<li>Fixes #28 adding compatibility with Nano 33 BLE by switching for <code>.h</code> header extension to <code>.hpp</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
1.3.3</h2>
<ul>
<li>Fixes #27 compilation error</li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
1.3.2</h2>
<ul>
<li>Fixes #2 preventing <code>shift()</code> and <code>pop()</code> operations misuse to mess up the buffer</li>
<li>Fixes #2 preventing <em>out of boundary</em> access using the <code>[]</code> operator</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
1.3.1</h2>
<ul>
<li>Fixes #21 _call to <code>abort()</code> is AVR-specific</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
1.3.0</h2>
<p >Most of the major improvements below have been contributed by <a href="https://github.com/Erlkoenig90">Erlkoenig90</a>: thank you Niklas!</p>
<ul>
<li>Slightly reduced both flash and heap footprint</li>
<li>Introduced <em>instance based</em> control over index data type</li>
<li>Replaced method <code>capacity()</code> in favor of the constant instance attribute <code>capacity</code></li>
<li>Added the <code>EventLogging</code> and <code>Interrupts</code> examples</li>
<li>Dropped the <code>CIRCULAT_BUFFER_XS</code> <em>macro switch</em> in favor of automatic index type identification</li>
<li>Added support for very large buffers (capacity can go up to <code>UINT32_MAX</code>)</li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
1.2.0</h2>
<ul>
<li>Added interrupt-related macro switch <code>CIRCULAR_BUFFER_INT_SAFE</code></li>
<li>Dropped unnecessary call to <code>memset</code> when clearing</li>
</ul>
<h2><a class="anchor" id="autotoc_md21"></a>
1.1.1</h2>
<ul>
<li>Added tests</li>
<li>Fixed <code>clear()</code> function</li>
<li>Fixed <code>pop()</code> function</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
1.1.0</h2>
<ul>
<li>Improved robustness against access outside the buffer boundaries</li>
<li>Fixed <code>pop()</code> and <code>shift()</code> implementations</li>
<li>Added test sketch</li>
<li>Added <code>capacity()</code> function</li>
<li>Added <code>debug()</code> function, disabled by pre-processor by default</li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
1.0.0</h2>
<ul>
<li>Initial implementation </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
